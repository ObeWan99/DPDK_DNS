# Основные переменные окружения и их значение

1. `ASAN_OPTIONS`

`ASAN_OPTIONS` — это переменная окружения, используемая для конфигурации поведения **AddressSanitizer** (ASan), который предназначен для обнаружения ошибок, связанных с доступом к памяти, таких как переполнения буфера, использование после освобождения, двойное освобождение и так далее.

**Основные параметры** `ASAN_OPTIONS`:

-  `detect_stack_use_after_return`:
    - Описание: Включает обнаружение использования памяти после возврата из функции (использование стека после возврата).
    - Пример: `ASAN_OPTIONS=detect_stack_use_after_return=1`
    
- `fast_unwind_on_malloc`:
    - Описание: Включает быструю развертку стека при аллокациях памяти (может ускорить выполнение, но снизить точность отчетов).
    - Пример: `ASAN_OPTIONS=fast_unwind_on_malloc=0`
    
- `halt_on_error`:
    - Описание: Прерывает выполнение программы при первом обнаружении ошибки.
    - Пример: `ASAN_OPTIONS=halt_on_error=0` (продолжает выполнение после обнаружения ошибки)
    
- `allocator_may_return_null`:
    - Описание: Указывает аллокатору возвращать NULL вместо завершения работы программы при нехватке памяти.
    - Пример: `ASAN_OPTIONS=allocator_may_return_null=1`
    
- `symbolize`:
    - Описание: Включает символизацию (разрешение адресов в имена функций и строк).
    - Пример: `ASAN_OPTIONS=symbolize=1`
    
- log_path:
    - Описание: Указывает путь для хранения логов AddressSanitizer.
    - Пример: `ASAN_OPTIONS=log_path=/path/to/logs/asan_log`

**Пример использования** `ASAN_OPTIONS`:    

Если вы хотите настроить `ASan` так, чтобы он продолжал выполнение после первой обнаруженной ошибки и записывал логи в файл `asan_log.txt`, вы можете установить переменную:

```sh
export ASAN_OPTIONS="halt_on_error=0:symbolize=1:log_path=./asan_log.txt"
```

2. `UBSAN_OPTIONS`

`UBSAN_OPTIONS` — это переменная окружения для настройки **UndefinedBehaviorSanitizer** (UBSan), который используется для обнаружения неопределенного поведения в коде C/C++, такого как разыменование нулевых указателей, переполнение знаковых чисел, неправильные преобразования типов и т.д.

**Основные параметры** `UBSAN_OPTIONS`:

- `halt_on_error`:
    - Описание: Останавливает выполнение программы при первой обнаруженной ошибке неопределенного поведения.
    - Пример: `UBSAN_OPTIONS=halt_on_error=1`
    
- `print_stacktrace`:
    - Описание: Включает вывод трассировки стека при обнаружении неопределенного поведения.
    - Пример: `UBSAN_OPTIONS=print_stacktrace=1`
    
- `suppressions`:
    - Описание: Указывает путь к файлу с подавлением сообщений об определенных типах ошибок.
    - Пример: `UBSAN_OPTIONS=suppressions=/path/to/suppressions.txt`
    
- `log_path`:
    - Описание: Указывает путь для записи логов UBSan.
    - Пример: `UBSAN_OPTIONS=log_path=./ubsan_log.txt`

**Пример использования** `UBSAN_OPTIONS`:

Если вы хотите, чтобы `UBSan` выводил трассировку стека и не прерывал выполнение при ошибках, установите:

```sh
export UBSAN_OPTIONS="print_stacktrace=1:halt_on_error=0"
```

3. `AFL_SKIP_CRASHES`

`AFL_SKIP_CRASHES` — это переменная окружения, используемая в AFL++ для указания инструмента игнорировать все файлы, которые вызывают сбои программы.

- Описание: Если эта переменная установлена в 1, AFL++ не будет перезапускать фуззинг с файлами, которые вызвали сбой программы, и продолжит тестирование с другими входными данными.
- Пример:

```sh
export AFL_SKIP_CRASHES=1
```

4. `AFL_NO_AFFINITY`

`AFL_NO_AFFINITY` — эта переменная указывает AFL++ не привязывать процесс фуззинга к конкретным ядрам процессора.

- Описание: Полезно, если вы хотите позволить операционной системе управлять распределением потоков по процессорам для более эффективного использования ресурсов.
- Пример:

```sh
export AFL_NO_AFFINITY=1
```

5. `AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES`

`AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES` — переменная, которая указывает AFL++ не учитывать отсутствие сбоев на разных хостах или при разных конфигурациях.

- Описание: Это полезно, если вы тестируете программу в разных средах и ожидаете, что некоторые сбои могут не воспроизводиться.
- Пример:

```sh
export AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1
```

# Как использовать переменные окружения в AFL++

Переменные окружения могут быть заданы непосредственно в командной строке перед запуском AFL++ или внутри вашего скрипта.

**Пример:**

1) **Задание переменных окружения непосредственно перед командой**

Вы можете установить переменные окружения прямо в командной строке перед запуском `afl-fuzz`. Это задает переменные только для конкретного выполнения команды и не сохраняет их для текущей сессии терминала.

```sh
ASAN_OPTIONS="halt_on_error=0:symbolize=1:log_path=./asan_log.txt" AFL_SKIP_CRASHES=1 afl-fuzz -i input_data -o output_data -- ./your_program @@
```

# Структура выходной директории AFL

```
output_directory/
├── crashes/
├── hangs/
├── queue/
├── .cur_input
├── fuzzer_stats
├── plot_data
├── README.txt
```

Давайте разберем, что означает каждый элемент этой структуры:

1) `crashes/`:
    - Этот каталог содержит входные данные, которые привели к сбоям (крашам) программы. Каждый файл в этом каталоге представляет собой тестовый случай, который вызвал ошибку выполнения. Обычно файлы имеют имена вида `id:<номер>,sig:<сигнал>`, где `<номер>` — уникальный идентификатор тестового случая, а `<сигнал>` — сигнал (например, `SIGSEGV`), вызвавший сбой.
    - Например, файл может иметь имя `id:000123,sig:11`.

2) `hangs/`:
    - Этот каталог содержит входные данные, которые привели к зависанию программы (выполнение заняло слишком много времени). Аналогично каталогу `crashes`, каждый файл в `hangs` представляет собой тестовый случай, который вызвал зависание. Файлы также имеют имена вида `id:<номер>,time:<время>`, где `<номер>` — уникальный идентификатор тестового случая, а `<время>` — время, потраченное на выполнение перед тем, как оно было признано зависанием.
    - Пример имени файла: `id:000045,time:5000`.

3) `queue/`:
    - Этот каталог содержит все тестовые случаи, которые AFL считает интересными для дальнейших мутаций. Обычно это входные данные, которые открыли новые пути выполнения программы или привели к другим важным событиям. Файлы в этом каталоге имеют имена вида `id:<номер>,<тип>`, где `<номер>` — уникальный идентификатор, а `<тип>` указывает на критерий, по которому этот тест был добавлен в очередь (например, orig для оригинальных тестов, `havoc` для тестов, полученных после мутаций и т. д.).
    - Пример имени файла: `id:000002,src:000000,op:havoc,rep:4`.

4) `.cur_input`:
    - Это временный файл, который AFL использует для хранения текущего входного тестового случая, передаваемого в программу в данный момент времени. Этот файл перезаписывается каждый раз, когда AFL запускает новый тест.

5) `fuzzer_stats`:
    - Этот файл содержит статистическую информацию о процессе фаззинга. Он обновляется в реальном времени и включает такие данные, как общее количество выполненных тестов, количество уникальных путей выполнения, количество сбоев, среднюю скорость тестирования и так далее.

6) `plot_data`:
    - Файл, содержащий данные, необходимые для построения графиков. Содержит информацию о процессе фаззинга в виде таблицы: время, количество найденных уникальных путей, количество сбоев, производительность и другие параметры, которые можно использовать для анализа процесса фаззинга с течением времени.

7) `README.txt`:
        Этот файл содержит краткую справочную информацию и описание того, что находится в данной директории.

- **Отслеживание прогресса:** Используя файлы `fuzzer_stats` и `plot_data`, пользователь может отслеживать прогресс фаззинга в реальном времени, видеть, сколько уникальных путей найдено, сколько времени затрачено, какая производительность и т. д.

- **Анализ сбоев и зависаний:** Файлы в каталогах `crashes` и `hangs` можно использовать для последующего анализа, чтобы понять, какие входные данные вызвали сбой или зависание и почему.

- **Оптимизация фаззинга:** AFL сохраняет интересные тестовые случаи в каталоге `queue`, чтобы повторно использовать их для дальнейших мутаций, что позволяет оптимизировать процесс поиска новых путей и уязвимостей.